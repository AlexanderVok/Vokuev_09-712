# ООП Класс Дерово

## Исходный код

* main.cpp

```C
#include <iostream>
#include "tree.h"
using namespace std;
int main() {
    tree*root = new tree(5);
    root->add(10);
    root->add(2);
    root->add(1);
    root->add(12);
    root->add(17);
    root->add(9);
    root->add(15);
    root->print();
    cout << endl << endl << endl;
    root->del(10);
    root->print();
    cout << endl << endl << endl;
    cout << "Searching " << " - "  <<root->search(12) << endl;
    return 0;
}
```

* tree.h

```C
#include "Node.h"
class tree {
private:
    Node*root;
public:
    tree();
    tree(int value);
    void add(int value);
    void print();
    void del(int element);
    bool search(int element);
};
```

* tree.cpp

```C
#include "tree.h"
#include <iostream>
using namespace std;

tree::tree() {
    this->root = nullptr;
}

tree::tree(int value) {
    this->root = new Node(value);
}

void tree::add(int value) {
    if (root == nullptr) {
        root = new Node(value);
    }
    else {
        Node*current = this->root;
        while (current != nullptr) {
            if (value <= current->getValue()) {
                if (current->getLeftSon() == NULL) {
                    Node* newNode = new Node(value);
                    current->setLeftSon(newNode);
                    current = NULL;
                }
                else {
                    current = current->getLeftSon();
                }
            }
            else {
                if (current->getRightSon() == NULL) {
                    Node* newNode = new Node(value);
                    current->setRightSon(newNode);
                    current = NULL;
                }
                else {
                    current = current->getRightSon();
                }
            }
        }
    }
}

void tree::print() {
    this->root->print(root , 0);
}

void tree::del(int element){
    if (root->getValue() == element)
    {
        Node*left_son = root->getLeftSon();
        Node*right_son = root->getRightSon();
        root->setLeftSon(NULL);
        root->setRightSon(NULL);
        delete root;
        if (right_son)
        {
            root = right_son;
            while (right_son->getLeftSon())
            {
                right_son = right_son->getLeftSon();
            }
            right_son->setLeftSon(left_son);
        }
        else
        {
            root = left_son;
        }
    }
    else {
        bool flag = false;
        Node*parent = root;
        Node*current = root;
        while (current&&!flag) {
            if (current->getValue() == element) {
                flag = true;
                int side = 0;
                Node*left_son = current->getLeftSon();
                Node*right_son = current->getRightSon();
                current->setLeftSon(NULL);
                current->setRightSon(NULL);
                if (current->getValue() > parent->getValue()) {
                    side = 1;
                }
                delete current;
                if (side == 1) {
                    if (right_son) {
                        parent->setRightSon(right_son);
                        while (right_son->getLeftSon())
                        {
                            right_son = right_son->getLeftSon();
                        }
                        right_son->setLeftSon(left_son);
                    }
                    else {
                        parent->setRightSon(left_son);
                    }
                }
                else {
                    if (right_son) {
                        parent->setLeftSon(right_son);
                        while (right_son->getLeftSon())
                        {
                            right_son = right_son->getLeftSon();
                        }
                        right_son->setLeftSon(left_son);
                    }
                    else {
                        parent->setLeftSon(left_son);
                    }
                }
            }
            else if(current->getValue() < element){
                parent = current;
                current = current->getRightSon();
            }
            else {
                parent = current;
                current = current->getLeftSon();
            }
        }
        if (!flag) {
            cout << "I can`t find element = " << element << endl;
        }

    }
}

bool tree::search(int element){
    Node*hellper = root;
    while (hellper != NULL)
    {
        if (hellper->getValue() == element)
        {
            return true;
        }
        else if (hellper->getValue() > element)
        {
            hellper = hellper->getLeftSon();
        }
        else
        {
            hellper = hellper->getRightSon();
        }
    }
    return false;
}
```

* Node.h

```C
class Node {
private:
    Node*leftSon;
    Node*rightSon;
    int value;
public:
    Node(int value);
    void setLeftSon(Node *leftSon);
    void setRightSon(Node *rightSon);
    void setValue(int value);
    Node*getLeftSon();
    Node*getRightSon();
    int getValue();
    void print(Node *root,int level);
};
```

* Node.cpp

```C
#include "Node.h"
#include <iostream>
using namespace std;

Node::Node(int value) {
    this->value = value;
    this->leftSon = nullptr;
    this->rightSon = nullptr;
}

int Node::getValue() {
    return this->value;
}

Node *Node::getLeftSon() {
    return this->leftSon;
}

Node *Node::getRightSon() {
    return this->rightSon;
}

void Node::setLeftSon(Node *leftSon) {
    this->leftSon = leftSon;
}

void Node::setRightSon(Node *rightSon) {
    this->rightSon = rightSon;
}

void Node::setValue(int value) {
    this->value = value;
}

void Node::print(Node *root, int level) {
    if (root != nullptr)
    {
        root->print(root->getRightSon(), level + 1);
        for (int i = 0; i < level; i++)
        {
            cout << "   ";
        }
        cout << root->getValue() << endl;
        root->print(root->getLeftSon(), level + 1);
    }
}
```
